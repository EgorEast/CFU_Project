//Открывает доступ к некоторым функциям
#pragma comment(lib, "ws2_32.lib")
//Подключаю библиотеку для работы с сетью
#include <WinSock2.h>
//Библиотека ввода и вывода
#include <iostream>
//
#include <windows.h>

//Убираю ошибку
#pragma warning(disable: 4996)

//Создаю массив сокетов для хранения нескольких подключений
SOCKET Connections[100];
//Переменная, хранящая индекс соединения
int Counter = 0;

//Функция принимающая индекс соединения в сокет массиве
void clientHandler(int index) {
	//Переменная, которая хранит размер сообщения
	int msg_size;
	//Бесконецный цикл, в котором будут приниматься и отправляться сообщения клиентов
	while (true) {
		//Принимаю пакет с размером строки и записываю его в переменную
		recv(Connections[index], (char*)&msg_size, sizeof(int), NULL);
		//Динамически создаю переменную, в которой будет храниться сообщение
		char* msg = new char[msg_size+1];
		//Не забываю про терминальный ноль
		msg[msg_size] = '\0';
		
		recv(Connections[index], msg, msg_size, NULL);
		//Цикл для отправки полученного сообщения всем клиентам до того, кто отправил
		for (int i = 0; i < index; i++) {
			//Перед отправкой сообщения отправляю размер этого сообщения
			send(Connections[index], (char*)&msg_size, sizeof(int), NULL);
			//Отправляю сообщение
			send(Connections[i], msg, msg_size, NULL);
		}
		//Пропускаю себя и отправляю остальным
		for (int i = index + 1; i < 100; i++)
			send(Connections[i], msg, msg_size, NULL);
		
		//Очищаю выделенную память, чтобы избежать утечку памяти
		delete[] msg;
	}

}

int main() {
	//Делаю так, чтобы читался русский язык как при вводе текста, так и при выводе
	//Установка кодовой страницы win-cp 1251 в поток ввода
	SetConsoleCP(1251);
	//Установка кодовой страницы win-cp 1251 в поток вывода
	SetConsoleOutputCP(1251);

	/*//Функция для загрузки библиотеки
	WSAStartup*/

	//Создаю структуру wsaData
	WSAData wsaData;
	//Создаю переменную WORD
	WORD DLLVEersion =
		//Это запрашиваемая версия библиотеки WinSock
		MAKEWORD(2,1);
	//Делаю проверку. Если библиотека загрузилась удачно
	if (
		//Функция для загрузки библиотеки
		WSAStartup(
			//Передаю запрашиваемую версию библиотеки
			DLLVEersion,
			//Ссылка на структуру wsaData
			&wsaData)
		//Тогда она вернет значение 0
		!= 0
		) 
	{
		//Если WSAStartup не вернет значение 0
		//Вывожу ошибку, что библиотека не загрузилась
		std::cout << "Ошибка. Библиотека не загрузилась!" << std::endl;
		//Выхожу из функции main
		exit(1);
	}

	//Структура, которая зранит информацию об адресе сокета
	//SOCKADDR_IN используется для интернет протокола
	SOCKADDR_IN addr;
	//Переменная, хранящая размер структуры SOCKADDR
	int sizeOfAddr = sizeof(addr);
	//sin_addr - это структура SOCKADDR_IN, которая хранит IP адрес
	addr.sin_addr.s_addr = inet_addr(
		//Здесь указан localhost, тоесть "этот компьютер"
		"127.0.0.1"
	);
	//sin_port - порт для идентификации программы поступающими данными
	addr.sin_port = htons(
		//Можно использовать любой порт, который не зарезервирован программой
		1111
	);
	//sin_family - семейство протоколов
	addr.sin_family = 
		//Для интернет протоколов указывается константа AF_INET
		AF_INET;

	/*Чтобы два компьютера смогли установить соединение,
	один из них должен запустить прослушивание на определенном порту*/

	//Создаю Сокет sListen, которому присвоил результат выполнения функции socket()
	SOCKET sListen = socket(
		//AF_INET означает, что будет использоваться семейство интернет протоколов
		AF_INET, 
		//SOCK_STREAM указывает на протокол, устанавливающий интернет соединение
		SOCK_STREAM, 
		//Этот параметр пока не нужен, поэтому NULL
		NULL
	);

	//Привязываю адрес сокету
	bind(
		//Предварительно созданный сокет
		sListen, 
		//Указатель на структуру SOCKADDR
		(SOCKADDR*)&addr, 
		//Размер структуры SOCKADDR
		sizeof(addr)
	);

	//Прослушивание порта в ожидании соединения со стороны клиента
	listen(
		//Пепредаю сокет
		//По этим данным функция определит по какому порту необходимо запустить прослушивание
		sListen, 
		//Максимально допустимое число запросов ожидающих обработки
		SOMAXCONN);

	//Принимаю соединение

	//Создаю новый сокет, чтобы удерживать соединение с клиентом
	SOCKET newConnection;

	//Цикл, обрабатывающий 100 с
	for (int i = 0; i < 100; i++) {
		//Принял новое соединение
		//accept возвращает указатель на новый сокет
		newConnection = accept(
			//Только что созданный и запущенный на прслушивание сокет
			sListen,
			//Указатель на структуру
			(SOCKADDR*)&addr,
			//Ссылка на размер структуры 
			&sizeOfAddr
		);
		/*После выполнения accept(), addr будет содержать сведения об IP адресе клиента,
		который подключился. Эти данные можно использовать для контроля доступа
		к серверу по IP адресу клиента*/

		//Если accept() вернет нулевое значение, значит клиент не смог подключиться к серверу
		//На этот случай проверка
		if (newConnection == 0) 
			std::cout << "Ошибка. Клиент не смог подключиться к серверу!\n";
		//Если соединение прошло
		else {
			std::cout << "Клиент подключился к серверу!\n";

			std::string msg = "Привет. Это моя первая сетевая программа!\n";
			//Создаю переменную, хранящую размер строки
			int msg_size = msg.size();
			//Отпавляю размер строки
			send(newConnection, (char*)&msg_size, sizeof(int), NULL);
			//Посылаю эту строчку клиенту
			send(
				/*Сокет, который хранит соединение с пользователем,
				которуму необходимо отправитьстрочку*/
				newConnection,
				//Сама строка
				msg.c_str(),
				//Размер строчки
				msg_size,
				//Пока не нужен
				NULL
			);
			//Передаю в массив данное соединение
			Connections[i] = newConnection;
			Counter++;

			//После выполнения данной функции сразу будут работать два потока или несколько\
			//Создю поток функцией CreateThread
			CreateThread(NULL, NULL, 
				//В которой будет выполняться функция clientHandler()
				//Это указатель на процедуру, с которой следует начать выполнение потока
				(LPTHREAD_START_ROUTINE)clientHandler,
				//С переданным параметром i
				//Это аргумент процедуры переданной предыдущим аргументом
				//(обычно здесь указатель на некую структуру)
				(LPVOID)(i),
				//Флаг
				NULL,
				//Куда стоит записать ThreadId созданного потока
				//В случае успеха процедура возвратит Handle созданного потока. 
				//В случае ошибки возвращается нулевое значение
				NULL);
		}
	}

	system("pause");
	return 0;
}