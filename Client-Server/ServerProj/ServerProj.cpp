//Открывает доступ к некоторым функциям
#pragma comment(lib, "ws2_32.lib")
//Подключаю библиотеку для работы с сетью
#include <WinSock2.h>
//Библиотека ввода и вывода
#include <iostream>
//Можно обойтись без этой библиотеки
//#include <windows.h>

////Подключаю библиотеку для работы с json файлами
//#include <json/json.hpp>
////Библиотека чтения и записи из файла
#include <fstream>

//Добавляю define, чтобы избежать некоторых ошибок
#define _WINSOCK_DEPRECATED_NO_WARNINGS
//Убираю ошибку
#pragma warning(disable: 4996)

using namespace std;
//using namespace nlohmann;

//Создаю массив сокетов для хранения нескольких подключений
SOCKET Connections[100];
//Переменная, хранящая индекс соединения
int Counter = 0;

//Перечисление для разных типов пакетов
enum Packet {
	//Отвечает за тип пакета
	P_ChatMessage,
	P_Test
};

//Ф-ция для обработки приходящих пакетов
bool ProcessPacket(int index, Packet packetType) {
	switch (packetType) {

		//Принятие отправленного сервером сообщения
	case P_ChatMessage: {
		//Переменная, хранящяя переданное клиентам сообщение
		char msg[260];
		recv(Connections[index], msg, sizeof(msg), NULL);
		//Цикл для отправки полученного сообщения всем клиентам до того, кто отправил
		for (int i = 0; i < index; i++) {
			//Отправляю тип пакета
			Packet msgtype = P_ChatMessage;
			send(Connections[i], (char*)&msgtype, sizeof(Packet), NULL);
			//Отправляю сообщение
			send(Connections[i], msg, sizeof(msg), NULL);
		}
		//Пропускаю себя и отправляю остальным
		for (int i = index + 1; i < 100; i++) {
			//Отправляю тип пакета
			Packet msgtype = P_ChatMessage;
			send(Connections[i], (char*)&msgtype, sizeof(Packet), NULL);
			//Отправляю сообщение
			send(Connections[i], msg, sizeof(msg), NULL);
		}
		break;
	}
	default:
		std::cout << "Пакет не был принят: " << packetType << std::endl;
		break;
	}

	//Если пакет обработан успешно, тогда true
	return true;
}

//Функция принимающая индекс соединения в сокет массиве
void clientHandler(int index) {
	//Хранит тип пакета
	Packet packetType;
	while (true) {
		//Принимаю и записываю тип пакета в packetType
		recv(Connections[index], (char*)&packetType, sizeof(Packet), NULL);
		//Проверка на возвращаемое значение ф-ции
		if (!
			//Вызываю и передаю пакет ф-ции ProcessPacket
			ProcessPacket(index, packetType)) {
			//Если не удалось обработать пакет, то выхожу из цикла
			break;
		}
	}
	//Вышел из цикла -> закрываю сокет
	closesocket(Connections[index]);
}

int main() {
	//Делаю так, чтобы читался русский язык как при вводе текста, так и при выводе
	//Установка кодовой страницы win-cp 1251 в поток ввода
	SetConsoleCP(1251);
	//Установка кодовой страницы win-cp 1251 в поток вывода
	SetConsoleOutputCP(1251);

	/*//Функция для загрузки библиотеки
	WSAStartup*/

	//Создаю структуру wsaData
	WSAData wsaData;
	//Создаю переменную WORD
	WORD DLLVEersion =
		//Это запрашиваемая версия библиотеки WinSock
		MAKEWORD(2,1);
	//Делаю проверку. Если библиотека загрузилась удачно
	if (
		//Функция для загрузки библиотеки
		WSAStartup(
			//Передаю запрашиваемую версию библиотеки
			DLLVEersion,
			//Ссылка на структуру wsaData
			&wsaData)
		//Тогда она вернет значение 0
		!= 0
		) 
	{
		//Если WSAStartup не вернет значение 0
		//Вывожу ошибку, что библиотека не загрузилась
		std::cout << "Ошибка. Библиотека не загрузилась!" << std::endl;
		//Выхожу из функции main
		exit(1);
	}

	//Структура, которая зранит информацию об адресе сокета
	//SOCKADDR_IN используется для интернет протокола
	SOCKADDR_IN addr;
	//Переменная, хранящая размер структуры SOCKADDR
	int sizeOfAddr = sizeof(addr);
	//sin_addr - это структура SOCKADDR_IN, которая хранит IP адрес
	addr.sin_addr.s_addr = inet_addr(
		//Здесь указан localhost, тоесть "этот компьютер"
		"127.0.0.1"
	);
	//sin_port - порт для идентификации программы поступающими данными
	addr.sin_port = htons(
		//Можно использовать любой порт, который не зарезервирован программой
		1111
	);
	//sin_family - семейство протоколов
	addr.sin_family = 
		//Для интернет протоколов указывается константа AF_INET
		AF_INET;

	/*Чтобы два компьютера смогли установить соединение,
	один из них должен запустить прослушивание на определенном порту*/

	//Создаю Сокет sListen, которому присвоил результат выполнения функции socket()
	SOCKET sListen = socket(
		//AF_INET означает, что будет использоваться семейство интернет протоколов
		AF_INET, 
		//SOCK_STREAM указывает на протокол, устанавливающий интернет соединение
		SOCK_STREAM, 
		//Этот параметр пока не нужен, поэтому NULL
		NULL
	);

	//Привязываю адрес сокету
	bind(
		//Предварительно созданный сокет
		sListen, 
		//Указатель на структуру SOCKADDR
		(SOCKADDR*)&addr, 
		//Размер структуры SOCKADDR
		sizeof(addr)
	);

	//Прослушивание порта в ожидании соединения со стороны клиента
	listen(
		//Пепредаю сокет
		//По этим данным функция определит по какому порту необходимо запустить прослушивание
		sListen, 
		//Максимально допустимое число запросов ожидающих обработки
		SOMAXCONN);

	//Принимаю соединение

	//Создаю новый сокет, чтобы удерживать соединение с клиентом
	SOCKET newConnection;

	//Цикл, обрабатывающий 100 с
	for (int i = 0; i < 100; i++) {
		//Принял новое соединение
		//accept возвращает указатель на новый сокет
		newConnection = accept(
			//Только что созданный и запущенный на прслушивание сокет
			sListen,
			//Указатель на структуру
			(SOCKADDR*)&addr,
			//Ссылка на размер структуры 
			&sizeOfAddr
		);
		/*После выполнения accept(), addr будет содержать сведения об IP адресе клиента,
		который подключился. Эти данные можно использовать для контроля доступа
		к серверу по IP адресу клиента*/

		//Если accept() вернет нулевое значение, значит клиент не смог подключиться к серверу
		//На этот случай проверка
		if (newConnection == 0) 
			std::cout << "Ошибка. Клиент не смог подключиться к серверу!\n";
		//Если соединение прошло
		else {
			std::cout << "Клиент подключился к серверу!\n";

			char msg[256] = "Привет. Это моя первая сетевая программа!\n";
			//Посылаю эту строчку клиенту

			//Отправляю тип пакета
			Packet msgtype = P_ChatMessage;
			send(newConnection, (char*)&msgtype, sizeof(Packet), NULL);

			//Отправляю тестовый пакет клиенту
			Packet testPacket = P_Test;
			send(newConnection, (char*)&testPacket, sizeof(Packet), NULL);

			send(
				/*Сокет, который хранит соединение с пользователем,
				которуму необходимо отправитьстрочку*/
				newConnection,
				//Сама строчка
				msg,
				//Размер строчки
				sizeof(msg),
				//Пока не нужен
				NULL
			);
			//Передаю в массив данное соединение
			Connections[i] = newConnection;
			Counter++;

			//После выполнения данной функции сразу будут работать два потока или несколько\
			//Создю поток функцией CreateThread
			CreateThread(NULL, NULL, 
				//В которой будет выполняться функция clientHandler()
				//Это указатель на процедуру, с которой следует начать выполнение потока
				(LPTHREAD_START_ROUTINE)clientHandler,
				//С переданным параметром i
				//Это аргумент процедуры переданной предыдущим аргументом
				//(обычно здесь указатель на некую структуру)
				(LPVOID)(i),
				//Флаг
				NULL,
				//Куда стоит записать ThreadId созданного потока
				//В случае успеха процедура возвратит Handle созданного потока. 
				//В случае ошибки возвращается нулевое значение
				NULL);

		}
	}

	system("pause");
	return 0;
}